# Writing Unit Tests

The unit tests are placed in the `tests/AzuriteUI.Web.UnitTests` project, and follow a naming scheme `{folder}/{class}_Tests.cs` - here `{folder}` is the folder name of the class under test and `{class}` is the class under test.  For example, if you were writing tests for class `Services/Azurite/AzuriteService.cs` in the AzuriteUI.Web project, you would place your test class in `Services/Azurite/AzuriteService_Tests.cs` within the `AzuriteUI.Web.UnitTests` project.

## General rules

* Group tests for a single method or property within regions.
* Use AAA (Arrange-Act-Assert) format.
* Decorate the test class with `[ExcludeFromCodeCoverage]`
* Use AwesomeAssertions, which is API compatible with FluentAssertions.
* Use NSubstitute for mocking.
* **DO NOT USE Moq or FluentAssertions** - these are forbidden libraries due to licensing.
* Use Microsoft.Extensions.TimeProvider.Testing to test the ITimeProvider implementation.
* Use an in-memory SQLite database for testing database context interactions.
* Do not write tests for library implementation details.
* Do not write tests to check exact error messages in exceptions.

### Testing log messages

* Avoid testing exact error messages within logs.
* Do not write tests that test debug log output.
* Use Microsoft.Extensions.Diagnostics.Testing TestLogger classes for checking logs.

### Mocking IConfiguration and IServiceProvider

* Do not mock IConfiguration or IServiceProvider
* Build a concrete IConfiguration using a ConfigurationBuilder with an in-memory provider
* Build a concrete IServiceProvider using a ServiceCollection when required

### Helper Methods

There are helper methods in Helpers/Utils.cs:

* `CreateAsyncEnumerable<T>(IEnumerable<T> items)`
* `CreateAsyncEnumerableWithException<T>(Exception exception)`
* `CreateAsyncEnumerableWithExceptionAfterItems(int itemCount, Exception exception)`

These should be used for creating `IAsyncEnumerable<T>` collections for testing purposes.

## Time outs

Add a 15 second timeout to each test that you write.

## Running tests

Use `dotnet test` commands to run the tests within the single test file that you modify.  

Then run `dotnet cake --target=Test` to run the entire test suite.  

Then analyze `artifacts/coverage/lcov.info` file (which is generated by the `dotnet cake` command), identify, analyze, and report any code coverage misses that were encountered in the class(es) that you are creating tests for.

Do not change any tests that you were not asked to work on.
